/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package elevator;

import elevator.event.*;
import elevator.model.*;
import elevator.scheduling.FlockScheduler;
import elevator.scheduling.Scheduler;
import elevator.simulation.DeferredEventQueue;
import elevator.simulation.FixedRateSimulator;
import elevator.simulation.WatchdogReactor;
import io.javalin.Javalin;
import io.javalin.core.validation.Validator;
import io.vavr.collection.List;
import io.vavr.collection.Stream;
import io.vavr.control.Try;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Objects;
import java.util.Set;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;

public class App implements EventEmitter, EventReactor {
    private static final Logger log = LoggerFactory.getLogger(App.class);
    public static final String CHRONICLE_DIR = "/tmp/elevator";

    private final int NUM_WORKERS = 16;
    private final int TICK_RATE = 100;
    private final int NUM_FLOORS = 2000;
    private final int NUM_ELEVATORS = 200;
    private int[] HOME_FLOORS;

    private DeferredEventQueue queue;
    private Scheduler sched;
    private RunnableEventBus bus;
    private ElevatorFactory elevatorFactory;
    private Building building;

    private AtomicLong reqs = new AtomicLong(0);
    private AtomicLong drops = new AtomicLong(0);
    private AtomicLong lastDrop = new AtomicLong(0);

    public void init() {
        HOME_FLOORS = new int[NUM_ELEVATORS];
        Stream.range(0, NUM_ELEVATORS).forEach(i -> {
            HOME_FLOORS[i] = i * NUM_FLOORS / NUM_ELEVATORS;
        });

        queue = new DeferredEventQueue();
        sched = new FlockScheduler();
        bus = new PartitionedEventBus(2048)
                .setTopicWorkers(EventTopic.SCHEDULING, NUM_WORKERS)
                .setTopicWorkers(EventTopic.ELEVATOR, 4)
                .setTopicPriority(EventTopic.ELEVATOR, Thread.MAX_PRIORITY);

        elevatorFactory = new HomingElevatorFactory(NUM_FLOORS, HOME_FLOORS);
//        elevatorFactory = new ElevatorFactory(NUM_FLOORS);

        building = Building.builder()
                .floors(NUM_FLOORS)
                .elevators(NUM_ELEVATORS)
                .setElevatorFactory(elevatorFactory)
                .setEventBus(bus)
                .eventQueue(queue)
                .scheduler(sched)
                .build();

//        LoggingEventListener console = new LoggingEventListener(log);
//        bus.attach(console);
// Monitor event stream from another process using Chronicle Queue:
        ChronicleAppenderListener chronicle = new ChronicleAppenderListener(CHRONICLE_DIR);
        bus.attach(chronicle);

        bus.attach(new WatchdogReactor());

        bus.attach(this); // This is also a listener for stress test monitoring
    }

    @Override
    public void syncEvent(EventBus bus1, Event event) {
        onEvent(bus1, event);
    }

    @Override
    public void onEvent(EventBus me, Event evt) {
        if (evt instanceof Event.DropPassenger) {
            drops.incrementAndGet();
//            log.info("Passengers served so far {}/{}", drops.get(), reqs.get());
        } else if (evt instanceof Event.ClockTick) {
            final long clock = ((Event.ClockTick) evt).getValue();
            if (clock % 30 == 0) {
                log.info("*** Time is now {} ***", clock);
                log.info("*** Event Bus Queue health: {} depth: {} ***", bus.health(), bus.getBacklog());
                log.info("*** Passengers served {}/{}. Last drop scheduled for {} ***", drops.get(), reqs.get(), lastDrop.get());
                final int idling = Stream.range(0, building.getNumElevators())
                        .map(building::getElevator)
                        .map(Elevator::getTrajectory)
                        .count(Trajectory::isIdle);

                final Number waitingForPickup = Stream.range(0, building.getNumFloors())
                        .map(building::getFloor)
                        .map(Floor::getPassengers)
                        .map(Set::size)
                        .sum();

                final Number inTransit = Stream.range(0, building.getNumElevators())
                        .map(building::getElevator)
                        .map(Elevator::getPassengers)
                        .map(Set::size)
                        .sum();

                log.info("*** Idle elevators: {}/{} Passengers waiting: {} In transit: {} ***",
                        idling, building.getNumElevators(),
                        waitingForPickup,
                        inTransit);

                if (clock > lastDrop.get() & drops.get() < reqs.get()) {
                    final List<Passenger> stranded = Stream.range(0, building.getNumFloors())
                            .map(building::getFloor)
                            .flatMap(Floor::getPassengers)
                            .toList();

                    final List<Passenger> riding = Stream.range(0, building.getNumElevators())
                            .map(building::getElevator)
                            .flatMap(Elevator::getPassengers)
                            .toList();

                    log.warn("*** Stranded passengers {} & {} ***", stranded, riding);
                }

            }
        } else if (evt instanceof Event.RequestAccepted) {
            reqs.getAndIncrement();
            final Long end = ((Event.RequestAccepted) evt).getRequest().getEndTime().getOrElse(0L);
            long oldLast = lastDrop.get();
            while (oldLast < end) {
                lastDrop.compareAndSet(oldLast, end);
                oldLast = lastDrop.get();
            }
        } else if (evt instanceof Event.MissedConnection) {
            reqs.getAndDecrement();
        }
    }

    @Override
    public RunnableEventBus getBus() {
        if (bus == null)
            init();

        return bus;
    }

    public CompletableFuture<Try<Void>> start() {
        return new FixedRateSimulator(getBus(), TICK_RATE, 1).startAsync();
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        App app = new App();
        var task = app.start();
        final ScheduledExecutorService executor = Executors.newScheduledThreadPool(4);

        Javalin server = Javalin.create().start(7000);
        task.thenAccept(vtry -> vtry.onSuccess(x -> {
            log.warn("??? I'm not sure how this happened but simulator shutdown spontaneously without an exception...");
            server.stop();
        }).onFailure(ex -> {
            log.error("Simulator died. Shutting down.", ex);
            server.stop();
        }));

        server.config.addStaticFiles("/web");
        server.get("/passenger", ctx -> {
            Validator<Integer> origin = ctx.queryParam("origin", Integer.class)
                    .check(i -> i > 0 && i < app.NUM_FLOORS);

            Validator<Integer> dest = ctx.queryParam("dest", Integer.class)
                    .check(i -> i > 0 && i < app.NUM_FLOORS && !Objects.equals(i, origin.get()));
            ;

            Passenger pass = new Passenger(dest.get());
            app.bus.fireTopic(EventTopic.SCHEDULING, new Event.ScheduleRequest(pass, origin.get()));
        });

        server.get("/stress", ctx -> {
            final long start = System.currentTimeMillis();

            if (app.bus.health() != EventBus.Health.GOOD) {
                ctx.result("Scheduling Bus is saturated. Try again later\n");
                ctx.status(503);
                return;
            }

            Validator<Integer> n = ctx.queryParam("n", Integer.class)
                    .check(i -> i > 0);

            Validator<Integer> rate = ctx.queryParam("rate", Integer.class)
                    .check(i -> i > 0 && i <= (10 * app.TICK_RATE));

            CountDownLatch latch = new CountDownLatch(n.get());
            long delay = (1000 * app.TICK_RATE) / rate.get();
            final ScheduledFuture<?> submitter = executor.scheduleAtFixedRate(() -> {
                if (app.bus.health() != EventBus.Health.GOOD)
                    return;

                if (latch.getCount() == 0)
                    return;

                int orig = ThreadLocalRandom.current().nextInt(0, app.NUM_FLOORS);
                int dest = ThreadLocalRandom.current().ints(0, app.NUM_FLOORS)
                        .filter(d -> d != orig)
                        .findFirst()
                        .getAsInt();

                Passenger pass = new Passenger(dest);
                app.bus.fireTopic(EventTopic.SCHEDULING, new Event.ScheduleRequest(pass, orig));
                latch.countDown();
            }, 0, delay, TimeUnit.MICROSECONDS);

            ctx.result("Launched stress test task\n");

            latch.await();
            submitter.cancel(false);

            final long finished = System.currentTimeMillis();
            final long dt = finished - start;
            ctx.result(String.format("Finished submitting %d requests in %dms. Effective rate is %d/s%n", n.get(), dt, (n.get() * 1000) / dt));
        });

        task.get();
    }

}
